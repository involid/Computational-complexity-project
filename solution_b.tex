\section*{Решение (b)}

Говоря, что множество ребер $S$ является разрезом графа $G$, если их удаление из $G$ разделяет граф на компоненты связности $V_1, \dots, V_k$ и в $S$ нет ребер, у которых оба конца лежат в одном множестве $V_i$. $w(S)$ — вес разреза.
Вес множества ребер определяется как сумма весов его элементов.
\newline
Алгоритм будет таков:

\begin{enumerate}
    \item Для каждого ребра $e \in E$ находим наименьший разрез $s_e$, который отделяет концы $e$.
    \item Сортируем полученные разрезы по возрастанию их весов. Получаем $s_1, s_2, \dots, s_m$, где $m = |E|$.
    \item Итеративно добавляем $s_i$ к искомому разрезу, пока не получим $k$-разрез. 
    Если $s_i \subseteq s_1 \cup s_2 \cup \dots \cup s_{i-1}$, то пропускаем данную итерацию, так как в ней нет смысла.
\end{enumerate}

Таким образом получаем разрезы $b_1, b_2, \dots, b_l$, объединение которых будет ответом.
Так как $s_1 \cup s_2 \cup \dots \cup s_m = E$, то при $k \leq n$ алгоритм действительно найдет $k$-разрез.
Алгоритм нахождения наименьшего разреза полиномиален $[1]$, поэтому первый пункт алгоритма работает за полином, так как представляет из себя $m$ запусков алгоритма поиска минимального разреза между вершинами, что эквивалентно нахождению максимального потока $[2]$.
Второй пункт — сортировка чисел, третий — подсчет компонент связности в графе $[3]$.
Итого алгоритм работает за полиномиальное время.

Докажем, что ответ алгоритма $b_1 \cup \dots \cup b_l$ дает приближение истинного ответа в 2 раза.
Пусть $A$ — минимальный $k$-разрез. 
Тогда $G(V, E - A)$ распадется на $k$ компонент связности $V_1, V_2, \dots, V_k$.
Пусть $a_i$ — множество ребер, которые имеют ровно один конец в $V_i$. 
Без ограничения общности отсортируем разрезы $a_1, a_2, \dots, a_k$ по возрастанию весов.
Тогда $2w(A) = \sum_{i = 1}^{k} w(a_i)$, так как каждое ребро из $a_i$ встречается в сумме 2 раза, в компонентах связности его концов.
Наша цель — доказать, что $w(b_1 \cup \dots \cup b_l) \leq \sum_{i = 1}^{l} w(b_i) \leq \sum_{i = 1}^{k} w(a_i) = 2w(A)$.
Сначала докажем, что $l \leq k - 1$.
$comps(S)$ будет обозначать количество компонент связности в графе при разрезе $S$.

\textbf{Лемма 1}: $\forall i \leq l$, $comps(b_1 \cup \dots \cup b_{i-1}) < comps(b_1 \cup \dots \cup b_{i-1} \cup b_{i})$, то есть на каждой итерации алгоритма размер разреза увеличивается.

\textbf{Доказательство}: По определению алгоритма $b_i \not\subseteq b_1 \cup \dots \cup b_{i-1}$, следовательно, $\exists e \in b_i - b_1 \cup \dots \cup b_{i-1}$.
Разрез $b_1 \cup \dots \cup b_{i-1}$ не удаляет $e$, значит, концы ребра находятся в одной компоненте связности.
Однако, применив разрез $b_{i}$, концы окажутся в разных компонентах связности, иначе не было бы смысла включать $e$ в $b_{i}$ (противоречие с минимальностью $s_j = b_i$).
Значит, разрез добавляет минимум одну компоненту связности.
$\qedsymbol{}$

\textbf{Следствие}: $l \leq k-1$.

\textbf{Доказательство}: Так как до первой итерации есть хотя бы одна компонента связности, а на каждой, по лемме 1, добавляется хотя бы одна, то количество итераций не превосходит $k-1$.
$\qedsymbol{}$

Для доказательства $\sum_{i = 1}^{l} w(b_i) \leq \sum_{i = 1}^{k} w(a_i)$ докажем более сильное утверждение.
Мы уже знаем, что на итерации номер $i$ алгоритма количество компонент связности, с добавлением $b_i$ к разрезу, увеличивается на $t \leq 1$.
Тогда сначала добавим к последовательности $b_i$ пустых множеств в количестве $Comps(G) - 1$, потом будем добавлять $b_i$ в последовательность $t$ раз, если он увеличивает размер разреза на $t$.
Таким образом получим разрезы $b_1, b_2, \dots, b_{k-1}$, среди которых соседи могут быть равны.

\textbf{Замечание}: Если вдруг конечный разрез является $k+1$-разрезом, то есть количество компонент связности больше $k$, то добавим $b_l$ столько раз, чтобы размер последовательности в точности равнялся $k-1$.

Получили новую последовательность $b_1, \dots, b_{k-1}$ и для неё докажем $\sum_{i = 1}^{k} w(b_i) \leq \sum_{i = 1}^{k} w(a_i)$. 
Для этого будем анализировать свойства $b_1, \dots, b_{k-1}$ и $a_1, \dots, a_{k-1}$ относительно всех разрезов.
Пусть $c_1, c_2, c_3, \dots, c_p$ — последовательность всех разрезов графа $G$ в возрастающем порядке, причём $b_1, \dots, b_{k-1}$ расположены в ней в правильном порядке, то есть $index(b_i) \leq index(b_j)$ при $i < j$, где $index(c)$ — это номер разреза $c$ в последовательности $c_1, c_2, \dots, c_p$.

\textbf{Лемма 2}: Существует последовательность $c_1, c_2, \dots$ состоящая из всех разрезов $G$, упорядоченная по возрастанию весов, в которой $b_1, \dots, b_{k-1}$ расположены в правильном порядке, со свойством $\forall \ 1 \leq i \leq index(b_{k-1})$, $c_1 \cup c_2 \cup \dots \cup c_i = b_1 \cup \dots \cup b_q$, где $q$ — наибольшее число, такое, что $index(b_q) \leq i$.
Другими словами, $c_1 \cup c_2 \cup \dots \cup c_i$ не изменится, если оставить в объединении только элементы из $b_1, \dots, b_{k-1}$.

\textbf{Доказательство}:
Предположим обратное. В любой последовательности, удовлетворяющей условиям, найдется $i \leq index(b_{k-1})$, такое что $b_1 \cup \dots \cup b_q \subsetneq c_1 \cup \dots \cup c_i$, где $q$ — наибольшее число, такое что $index(b_q) \leq i$.
Наименьшее такое $i$ назовем точкой разрыва.

Возьмем последовательность $c_1, c_2 \dots c_p$ с наибольшей точкой разрыва.
Пусть $i$ — точка разрыва в ней, $b_1 \cup \dots \cup b_q \subsetneq c_1 \cup \dots \cup c_i$.
Понятно, что $b_q \neq c_i$, иначе $i$ был бы не минимальным.
Еще $q < k-1$, иначе $index(b_{k-1}) \leq i$, что приводит к выводу, что либо $b_{q} = c_i$, либо $index(b_{k-1}) < i$.

Пусть $index(b_{q+1}) = j$.
$w(c_j) > w(c_i)$, так как иначе мы бы поменяли местами $c_i$ и $c_j$, получив другую последовательность, удовлетворяющую условиям, с более большой точкой разрыва.
По выбору $i$ и факту, что $c_i \neq b_q$, $b_1 \cup \dots \cup b_q = c_1 \cup \dots \cup c_{i - 1}$.
Тогда $\exists e \in c_i - b_1 \cup b_2 \cup \dots \cup b_q$.
Пусть $b_e$ — элемент последовательности, который отвечает минимальному разрезу, отделяющему концы $e$.
С одной стороны, $e \in c_i$, значит $w(b_e) \leq w(c_i)$, с другой стороны, $b_e \neq b_1, b_2, \dots, b_q$, $w(b_e) \leq w(c_i) < w(b_{q+1})$, что является противоречием.
$\qedsymbol{}$

Пусть $A_i = a_1 \cup \dots \cup a_q$, где $q$ — наибольшее такое число, что $index(a_q) \leq i$. Аналогично определим $B_i$ для последовательности $b_1, \dots, b_{k-1}$.
Тогда из леммы 2 можно записать в виде $\forall i \leq index(b_{k-1})$, $c_1 \cup \dots \cup c_i = B_i$.
Отсюда же видно, что $comps(A_i) \leq comps(B_i)$, так как $A_i \subseteq c_1 \cup \dots \cup c_i = B_i$.

\textbf{Лемма 3}: $\forall 1 \leq i \leq index(a_{k-1})$, $comps(A_i) \geq q + 1$, где $q$ — количество элементов $a_1, \dots, a_{k-1}$ в $c_1, \dots, c_i$.

\textbf{Доказательство}: Вспомним, откуда взялись $a_1, \dots, a_{k-1}$. Разрез $a_t$ отделяет множество $V_t$ из графа $G$.
Следовательно, разрез $A_i$ будет иметь компоненты связности $V_1, \dots, V{q}$ и $V - V_1, \dots, V_{q}$, не пустой, так как $q < k$.
$\qedsymbol{}$

Комбинируя леммы 2 и 3, получаем $comps(B_i) \geq q + 1$.
Вспомним структуру $b_i$: если $b_i \neq b_{i+1}$, то $comps(b_1 \cup \dots \cup b_i) = i + 1$.
Тогда $comps(B_i) \geq q + 1$ подразумевает, что $index(b_{q+1}) \leq i$.
Отсюда следует, что если в $c_1, \dots, c_i$ есть $q$ элементов последовательности $a_1, \dots, a_{k-1}$, то есть хотя бы $q$ элементов последовательности $b_1, \dots, b_{k-1}$.
Это позволяет сделать соответствие между последовательностями со свойством $w(b_i) \leq w(a_i)$, так как $b_i$ идет в последовательности $c_1, c_2, \dots$ раньше, чем $a_i$.

\textbf{Теорема}: Описанный выше алгоритм работает с точностью $(1 - 1/k)$.

\textbf{Доказательство}: Получили $w(b_i) \leq w(a_i)$, тогда $w(b_1 \cup \dots \cup b_{k-1}) \leq w(b_1) + \dots + w(b_{k-1}) \leq w(a_1) + \dots + w(a_{k-1}) \leq \frac{k - 1}{k}(w(a_1) + \dots + w(a_{k-1}) + w(a_k)) = \frac{k - 1}{k} \cdot 2w(A)$, откуда $w(b_1 \cup \dots \cup b_{k-1}) \leq 2(1 - 1/k)w(A)$.
$\qedsymbol{}$
